/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package code;
import com.opencsv.CSVReader;
import com.opencsv.exceptions.CsvValidationException;

import java.io.*;
import java.nio.ByteBuffer;
import java.util.*;
import java.util.stream.Collectors;

public class App {



    public static void main(String[] args) throws IOException, CsvValidationException {


        // ------------Real Dataset (AirBnB)------------

        //Importing csv in java (openCSV dependency has also been added)
        InputStreamReader streamReader = new InputStreamReader(App.class.getClassLoader().getResourceAsStream("listings.csv"));
        CSVReader reader = new CSVReader(streamReader);
        String[] nextLine;
        List<String> stringArr = new ArrayList<>();
        while ((nextLine = reader.readNext()) != null) {
            stringArr.add(nextLine[6]);
        }

        // ------------Count-Min Sketch------------

        // Creating a hashmap and then keySet just to only get unique values for displaying (just for running through a unique array)
        Map<String, Integer> stringToIntMap = new HashMap<>();
        for(String elem : stringArr){
            Integer mapIndex = 0;
            stringToIntMap.put(elem, mapIndex);
        }
        Set<String> keySet = stringToIntMap.keySet();


        // Add item frequency to the count-min sketch data structure
        CountMinSketch countMinSketch = new CountMinSketch(20, 15, 1000003);
        for (String neighborhood : stringArr) {
            // convert string to int (or bytes first)
            byte[] bytes = neighborhood.getBytes();
            int neighborhoodInt = ByteBuffer.wrap(bytes).getInt();
            countMinSketch.add(neighborhoodInt, 1);
        }

        //Calculating actual frequency
        Map<String, Long> actualFrequency = stringArr.stream()
                .collect(Collectors.groupingBy(s -> s, Collectors.counting()));

        int completeNumber = 0;
        //Printing Estimated frequencies and Actual frequencies
        for(String neighborhood : keySet){
            // key string to int
            byte[] bytes = neighborhood.getBytes();
            int neighborhoodInt = ByteBuffer.wrap(bytes).getInt();
            System.out.println(" " + neighborhood + "-- Estimated Frequency: " + countMinSketch.estimateCount(neighborhoodInt)
            + " --ACTUAL FREQUENCY: " + actualFrequency.get(neighborhood));

            completeNumber += actualFrequency.get(neighborhood);
        }

        System.out.println("------");
        System.out.println("Complete number of neighborhoods -> " + completeNumber);


        //---------------Heavy Hitters -----------------------

        ArrayList<String> heavyHittersList = new ArrayList<>();
        HeavyHittersCountMin heavyHitters = new HeavyHittersCountMin(8000, countMinSketch, heavyHittersList);
        for(String neighborhood : keySet){

            //Type conversion
            byte[] bytes = neighborhood.getBytes();
            int neighborhoodInt = ByteBuffer.wrap(bytes).getInt();

            heavyHitters.update(neighborhoodInt);
        }

        //Show list of heavy hitters
        heavyHittersList = heavyHitters.query();
        System.out.println("-- List of heavy hitters -- ");
        for(String elem : heavyHittersList){
            System.out.println(elem);
        }

        /*---------------Bloom filter-------------------*/

        BloomFilter bloomFilter = new BloomFilter(120, 5);

        //Adding elements to bloom filter
        for(String neighborhood : stringArr){
            byte[] bytes = neighborhood.getBytes();
            int neighborhoodInt = ByteBuffer.wrap(bytes).getInt();
            bloomFilter.add(neighborhoodInt);
        }

        //Seeing if set contains element
        byte[] bytes = "Neverland".getBytes();
        int neighborhoodInt = ByteBuffer.wrap(bytes).getInt();
        System.out.println(bloomFilter.contains(neighborhoodInt));


    }

}
